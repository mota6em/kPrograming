<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="hu" xml:lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Konkurens programoz√°s feladatsor</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="labs.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Konkurens programoz√°s feladatsor</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#java-ism√©tl√©s" id="toc-java-ism√©tl√©s">Java
ism√©tl√©s</a></li>
<li><a href="#sz√°lak-k√©sz√≠t√©se" id="toc-sz√°lak-k√©sz√≠t√©se">Sz√°lak
k√©sz√≠t√©se</a></li>
<li><a href="#synchronized" id="toc-synchronized"><code
class="sourceCode java"><span class="kw">synchronized</span></code></a></li>
<li><a href="#executorservice" id="toc-executorservice"><code
class="sourceCode java"><span class="bu">ExecutorService</span></code></a></li>
<li><a href="#szinkroniz√°lt-adatszerkezetek"
id="toc-szinkroniz√°lt-adatszerkezetek">Szinkroniz√°lt
adatszerkezetek</a></li>
<li><a href="#holtpont" id="toc-holtpont">Holtpont</a></li>
<li><a href="#wait-notify" id="toc-wait-notify"><code
class="sourceCode java">wait</code>-<code
class="sourceCode java">notify</code></a></li>
<li><a href="#explicit-z√°rak" id="toc-explicit-z√°rak">Explicit
z√°rak</a></li>
<li><a href="#gyakorl√≥-feladat" id="toc-gyakorl√≥-feladat">Gyakorl√≥
feladat</a></li>
<li><a href="#beadand√≥-feladatok" id="toc-beadand√≥-feladatok">Beadand√≥
feladatok</a></li>
</ul>
</nav>
<!--
Compile it like this:
    pandoc labs.md -s --toc -L scripts/slides.lua -V lang=en -o labs-en.html
    pandoc labs.md -s --toc -L scripts/slides.lua -V lang=hu -o labs-hu.html
-->
<h1 class="hu" id="java-ism√©tl√©s">Java ism√©tl√©s</h1>
<ol type="1">
<li><p>Egyszer≈± Java oszt√°ly</p>
<p>K√©sz√≠ts egy oszt√°lyt <code>Employee</code> n√©ven. Az
<code>Employee</code> oszt√°lynak k√©t priv√°t adattagja van,
<code>name</code> (n√©v) √©s <code>salary</code> (fizet√©s). K√©sz√≠ts az
oszt√°lyhoz nyilv√°nos konstruktort, ami inicializ√°lja ezt a k√©t mez≈ët.
Ezenk√≠v√ºl k√©sz√≠ts lek√©rdez≈ë met√≥dust mindk√©t mez≈ëh√∂z, valamint egy olyan
met√≥dust, amely a fizet√©st egy adott sz√°zal√©kkal megemeli (param√©terk√©nt
√°tadott lebeg≈ëpontos √©rt√©k).</p>
<p>Ehhez a feladathoz √©s a k√∂vetkez≈ëkh√∂z is k√©sz√≠ts egy
<code>main</code> f√ºggv√©nnyel rendelkez≈ë oszt√°lyt, amelyik kipr√≥b√°lja az
√∂sszes. Ford√≠tsd le √©s futtasd a k√≥dot.</p></li>
<li><p>Absztrakt oszt√°ly √©s √∂r√∂kl≈ëd√©s</p>
<p>Tedd az <code>Employee</code> oszt√°lyt absztraktt√°. K√©sz√≠ts k√©t
oszt√°lyt, amely bel≈ële sz√°rmazik le <code>Manager</code> √©s
<code>Subordinate</code> (beosztott) n√©ven. Tedd az
<code>Employee</code> oszt√°ly <code>salary</code> mez≈ëj√©nek lek√©rdez≈ë
met√≥dus√°t absztraktt√°, az eredeti m≈±k√∂d√©st meg tedd √°t egy ezt
fel√ºldefini√°l√≥ met√≥dusba a <code>Subordinate</code> oszt√°lyban.</p>
<p>A <code>Manager</code> oszt√°ly t√°roljon egy list√°t, amelyben
<code>Employee</code> t√≠pus√∫ elemek szerepelnek. K√©sz√≠ts met√≥dusokat a
<code>Manager</code> oszt√°lyba, amelyek <code>Employee</code>
p√©ld√°nyokat adnak hozz√° √©s t√∂r√∂lnek. Defini√°ld fel√ºl a
<code>getSalary()</code> met√≥dust a <code>Manager</code> oszt√°lyban is
olyan m√≥don, hogy a saj√°t fizet√©s√©hez adja hozz√° a list√°j√°ban szerepl≈ë
√∂sszes <code>Employee</code> fizet√©s√©nek 5%-√°t, √©s ezt az √©rt√©ket adja
vissza.</p></li>
<li><p>Interf√©sz</p>
<p>K√©sz√≠ts egy interf√©szt <code>SalariedEntity</code> n√©ven, amelynek
egyetlen <code>getSalary()</code> met√≥dusa van. M√≥dos√≠tsd az
<code>Employee</code> oszt√°lyt √∫gy, hogy val√≥s√≠tsa meg ezt az
interf√©szt. Ezen k√≠v√ºl k√©sz√≠ts egy az interf√©szt szint√©n megval√≥s√≠t√≥
<code>Subcontractor</code> (alv√°llalkoz√≥) oszt√°lyt is. Az
alv√°llalkoz√≥knak a nev√ºk helyett az ad√≥sz√°m√°t (<code>long</code>)
t√°roljuk.</p></li>
<li><p>üè† H√°zi feladat</p>
<p>K√©sz√≠ts egy <code>Company</code> nev≈± oszt√°lyt, amely egy
<code>SalariedEntities</code> elemekb≈ël √°ll√≥ list√°t tartalmaz. K√©sz√≠ts
met√≥dusokat, amelyek ehhez a list√°hoz adnak elemeket, illetve t√∂r√∂lnek
bel≈ële, valamint egy olyat is, amely az <code>Employee</code> t√≠pus√∫
elemek fizet√©s√©t egy adott sz√°zal√©kkal megemeli.</p></li>
</ol>
<h1 class="hu" id="sz√°lak-k√©sz√≠t√©se">Sz√°lak k√©sz√≠t√©se</h1>
<ol type="1">
<li><p>K√©sz√≠ts k√©t sz√°lat √©s futtasd ≈ëket. A sz√°lak √≠rj√°k ki a
<code>hello</code> √©s a <code>world</code> sz√∂vegeket sokszor (pl.
egym√°s ut√°n <code>10_000</code> alkalommal) a
<code>System.out.println()</code> haszn√°lat√°val.</p>
<p>A sz√°lak logik√°j√°t a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html"><code>Thread</code></a>
oszt√°ly √°ltalad k√©sz√≠tett lesz√°rmazottj√°nak <code>run</code> met√≥dus√°ba
kell le√≠rni, a sz√°lak ind√≠t√°s√°hoz pedig p√©ld√°nyos√≠t√°s ut√°n a
<code>start()</code> met√≥dust kell megh√≠vni.</p>
<ol type="a">
<li>Figyeld meg, hogy a kimenetek √∂sszef√©s√ºl≈ëdnek.
<ol type="a">
<li>√çrj olyan megold√°st is, ahol karakterr≈ël karakterre √≠rod ki a
sz√∂vegeket, a <code>System.out</code> objektum <code>print()</code>
m≈±velet√©t haszn√°lva, nem a <code>println()</code> seg√≠ts√©g√©vel.</li>
</ol></li>
<li>Pr√≥b√°ld ki, mi t√∂rt√©nik, ha sz√°lind√≠t√°s helyett a fenti k√©t ki√≠r√°st
nem a <code>start()</code>, hanem a <code>run()</code> met√≥dus
megh√≠v√°s√°val futtatod.</li>
<li>K√©sz√≠ts olyan megold√°st is, ahol a sztenderd kimenet helyett egy
f√°jlba √≠rod a kimenetet <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PrintWriter.html"><code>PrintWriter</code></a>
haszn√°lat√°val.</li>
<li>Oldd meg a feladatot √∫gy is, hogy a <code>Thread</code> objektumokat
k√ºl√∂nf√©le m√≥dokon k√©sz√≠ted el. Gondold meg mindegyik esetben, hogy le
lehet-e √∫gy √≠rni a k√≥dot, hogy a k√©t sz√°l tev√©kenys√©g√©nek k√∂z√∂s r√©sze
(ki kell √≠rni valamit) nem ism√©tl≈ëdik a k√≥dban, hanem csak egyszer
jelenik meg, √©s a sz√°lak ezt param√©terezik azzal, hogy pontosan milyen
sz√∂veget kell ki√≠rni.
<ul>
<li><code>Thread</code> lesz√°rmazott oszt√°llyal</li>
<li><code>Runnable</code> interf√©szt megval√≥s√≠t√≥ oszt√°llyal</li>
<li><code>Thread</code>-b≈ël sz√°rmaz√≥ n√©vtelen oszt√°llyal</li>
<li><code>Runnable</code>-b≈ël sz√°rmaz√≥ n√©vtelen oszt√°llyal</li>
<li><code>Thread</code> konstruktor√°nak lambda √°tad√°s√°val</li>
</ul></li>
</ol></li>
<li><p>K√≠s√©rletezz sz√°lakkal.</p>
<ul>
<li>Nevezd el a sz√°lakat (<a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#setName(java.lang.String)"><code>setName</code></a>).</li>
<li>K√©sz√≠ts egy <a
href="https://download.java.net/java/early_access/loom/docs/api/java.base/java/lang/ThreadGroup.html"><code>ThreadGroup</code></a>
p√©ld√°nyt, √©s add azt √°t a sz√°lak els≈ë param√©ter√©nek.
<ul>
<li>Az oszt√°ly <a
href="https://download.java.net/java/early_access/loom/docs/api/java.base/java/lang/ThreadGroup.html#activeCount()"><code>activeCount()</code></a>
√©s <a
href="https://download.java.net/java/early_access/loom/docs/api/java.base/java/lang/ThreadGroup.html#list()"><code>list()</code></a>
met√≥dusait haszn√°lva figyeld meg a sz√°lak fut√°s√°t.</li>
</ul></li>
<li>‚ûø Opcion√°lis: IDE seg√≠ts√©g√©vel sz√ºneteltesd a sz√°lak fut√°s√°t
<em>debug</em> m√≥dban (suspend).
<ul>
<li>Vizsg√°ld meg a v√°ltoz√≥ik tartalm√°t a Debugger seg√≠ts√©g√©vel.</li>
<li>√çrd √°t a v√°ltoz√≥k √©rt√©k√©t, √©s folytasd a futtat√°st.</li>
</ul></li>
</ul></li>
<li><p>üè† H√°zi feladat: Ellen≈ërizd, hogy a t√∂bb sz√°lon val√≥ v√©grehajt√°s
jelent≈ës gyorsul√°st okoz(hat).</p>
<ul>
<li>Add √∂ssze az <code>1..1_000_000_000</code> intervallum sz√°mait egy
sz√°lon. M√©rd ki a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/System.html#nanoTime()"><code>System.nanoTime()</code></a>
felhaszn√°l√°s√°val, ez mennyi id≈ëbe telik.</li>
<li>Ezut√°n ind√≠ts <code>10</code> sz√°lat, amik seg√≠ts√©g√©vel add √∂ssze az
<code>1..1_000_000_000</code> intervallum sz√°mait:
<ul>
<li>Az els≈ë sz√°l: az <code>1..100_000_000</code> intervallumon dolgozik,
a m√°sodik sz√°l a <code>100_000_001..200_000_000</code> intervallumon,
stb.</li>
<li>Az √∂sszegz√©st egy <code>static</code> v√°ltoz√≥ba vezesd.</li>
<li>M√©rd ki a <code>System.nanoTime()</code> felhaszn√°l√°s√°val, ez mennyi
id≈ëbe telik, √©s ezt √≠rd ki a sz√°l lefut√°s√°nak v√©g√©n.</li>
</ul></li>
</ul></li>
<li><p>üì∫ P√©lda: alternat√≠v m√≥dszer sz√°lak l√©trehoz√°s√°ra; sz√°lak
bev√°r√°sa, sz√°lakon bel√ºli v√°rakoz√°s, √©s sz√°lak megszak√≠t√°sa</p>
<p>A <code>DemoBasicThreading.java</code> futtat√°sa bemutat n√©h√°ny
alapvet≈ë sz√°lm≈±veletet. Mindegyik m≈±velethez k√ºl√∂n f√°jl tartozik, a
<code>DemoBasicThreadingHelper.java</code> pedig seg√©df√ºggv√©nyeket
tartalmaz.</p>
<ol type="1">
<li>Sz√°l l√©trehoz√°sa √∂r√∂kl√©ssel:
<code>ClassExtendingThread.java</code></li>
<li>Sz√°l l√©trehoz√°sa interf√©sz megval√≥s√≠t√°ssal:
<code>ClassImplementingRunnable.java</code></li>
<li>Sz√°l ind√≠t√°sa: <code>ThreadCreationExample.java</code></li>
<li>Sz√°l bev√°r√°sa, altat√°s √©s szinkroniz√°lt met√≥dusok:
<code>JoinSleepSynchronizedExample.java</code></li>
<li>Sz√°l megszak√≠t√°sa: <code>LifecycleInterruptExample.java</code></li>
</ol></li>
<li><p>Join, sleep, interrupt</p>
<ol type="a">
<li>Alak√≠tsd √°t a <strong>K√©sz√≠ts k√©t sz√°lat‚Ä¶</strong> feladatot √∫gy,
hogy miut√°n mindk√©t sz√°l v√©gzett, √≠rja ki a <code>k√©sz</code> sz√≥t.
<ul>
<li>Hogy gyorsabban v√©gezzen a program, √≠rd √°t 1000-re a termin√°l√°si
felt√©telben szerepl≈ë konstanst.</li>
<li>Haszn√°ld a <code>Thread</code> oszt√°ly <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#join()"><code>join</code></a>
met√≥dus√°t egy sz√°l bev√°r√°s√°hoz.
<ul>
<li>Ne felejtsd el elkapni az <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/InterruptedException.html"><code>InterruptedException</code></a>
kiv√©telt.</li>
</ul></li>
</ul></li>
<li>V√°rakoz√°s sz√°lon bel√ºl<br />
Alak√≠tsd √°t az el≈ëz≈ë programot √∫gy, hogy minden k√©t ki√≠r√°s k√∂z√∂tt 5
ezredm√°sodpercet v√°rakozzon. Ehhez haszn√°ld a <code>Thread</code>
oszt√°ly <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#sleep(long)"><code>sleep</code></a>
statikus met√≥dus√°t.
<ul>
<li>Ne felejtsd el elkapni az <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/InterruptedException.html"><code>InterruptedException</code></a>
kiv√©telt.</li>
<li>Megjegyz√©s: a Jav√°ban van egy <code>wait()</code> nev≈±, szint√©n
k√∂zismert met√≥dus, de annak teljesen m√°s a szerepe.</li>
</ul></li>
<li>Sz√°lak fut√°s√°nak megszak√≠t√°sa<br />
Szak√≠tsd meg az el≈ëz≈ë programban a sz√°lakat egy m√°sodperc fut√°s ut√°n.
Ehhez haszn√°ld a <code>Thread</code> oszt√°ly <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#interrupt()"><code>interrupt</code></a>.</li>
<li>Megszak√≠tott sz√°l √∫jraind√≠t√°sa?<br />
Pr√≥b√°ld meg √∫jraind√≠tani a megszak√≠tott sz√°lakat. Mi t√∂rt√©nik?</li>
</ol></li>
<li><p>Join, sleep, interrupt #2</p>
<ul>
<li>Ind√≠ts el 10 sz√°lat, mely mind elsz√°mol <code>1</code>-t≈ël
<code>10_000</code>-ig √©s minden sz√°mot ki√≠r egy f√°jlba (<a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PrintWriter.html"><code>PrintWriter</code></a>),
melynek a neve legyen azonos a sz√°l nev√©vel (<a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#getName()"><code>getName()</code></a>),
kiterjeszt√©se tetsz≈ëleges.
<ul>
<li>Fontos, hogy minden egyes ki√≠r√°sn√°l √∫jra nyisd meg, majd z√°rd be a
f√°jlt.</li>
<li>Elegend≈ë, ha a f√°jl mindig csak az utols√≥ iter√°lt sz√°mot tartalmazza
(fel√ºl lehet √≠rni a kor√°bbit).</li>
</ul></li>
<li>A sz√°lakat ind√≠t√≥ met√≥dus v√°rjon 1mp-et (<a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#sleep(long)"><code>Thread.sleep</code></a>),
majd √≠rja ki a sz√°lakhoz tartoz√≥ f√°jlok utols√≥ sor√°t a sztenderd
kimenetre. √âszreveszel-e valami furcsas√°got?</li>
<li>M√≥dos√≠tsd a megold√°st √∫gy, hogy m√©g a ki√≠r√°s el≈ëtt <em>bev√°rod</em>
a sz√°lakat. Ehhez h√≠vd meg minden sz√°lon a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#join()"><code>join()</code></a>
m≈±veletet.</li>
<li>A <code>Thread.sleep</code> √©s a <code>Thread.join</code> m≈±veletek
ellen≈ërz√∂tt kiv√©teleket dobhatnak, melyeket megfelel≈ë
<code>try-catch</code> blokkal kell kezelni. A feladat megold√°s√°hoz most
el√©g egy √ºres <code>catch</code> √°gat l√©trehozni, nem kell
‚Äúkiv√©telkezel≈ë logika‚Äù.</li>
</ul></li>
<li><p>üè† H√°zi feladat</p>
<p>A ‚Äú<strong>Sz√°lak bev√°r√°sa</strong>‚Äù feladat megold√°s√°t b≈ëv√≠tsd egy
olyan sz√°llal, amelyik m√°sodpercenk√©nt ki√≠rja, h√°ny sz√°l akt√≠v m√©g
(<code>Thread.currentThread().getThreadGroup().activeCount()</code>). Ha
m√°r csak ez a sz√°l maradt meg, l√©pjen ki.</p>
<ul>
<li>A m√°sodpercenk√©nti m≈±k√∂d√©st el≈ësz√∂r a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#sleep(long)"><code>Thread.sleep</code></a>
h√≠v√°s√°val oldd meg.</li>
<li>‚ûø Opcion√°lis: K√©sz√≠ts egy m√°sik megold√°st is, ebben a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Timer.html"><code>Timer</code></a>
oszt√°ly <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Timer.html#scheduleAtFixedRate(java.util.TimerTask,long,long)"><code>scheduleAtFixedRate</code></a>
met√≥dus√°t haszn√°ld.</li>
</ul></li>
<li><p>üè† H√°zi feladat: B√°ny√°szok √©s √©p√≠t≈ëk</p>
<p>A feladat egy szimul√°ci√≥ l√©trehoz√°sa, ahol k√©tf√©le dolgoz√≥ (ezeket
sz√°lak testes√≠tik meg) pr√≥b√°l fel√©p√≠teni 5 h√°zat ‚Äì a b√°ny√°szok (miner)
az aranyb√°ny√°b√≥l b√°ny√°sznak aranyat, amib≈ël az √©p√≠t√©szek (builder)
tudnak h√°zakat √©p√≠teni.</p>
<ul>
<li><code>Configuration.java</code>: Ez az oszt√°ly a szimul√°ci√≥
konfigur√°ci√≥j√°t tartalmazza: meddig tartson egy √©p√≠tkez√©s, h√°ny
dolgoz√≥nk legyen stb. A megold√°s sor√°n ehhez nem kell hozz√°ny√∫lni.</li>
<li><code>Resources.java</code>: Ez az oszt√°ly felel az√©rt, hogy nyomon
k√∂vesse, mennyi aranyat lehet m√©g b√°ny√°szni a b√°ny√°b√≥l, mennyi arannyal
rendelkeznek a dolgoz√≥k, illetve h√°ny h√°zat √©p√≠tettek m√°r fel. Egyel≈ëre
ehhez sem kell hozz√°ny√∫lni.</li>
<li><code>ThreadCraft.java</code>: Itt tal√°lhat√≥ a <code>main</code>
met√≥dus, illetve a dolgoz√≥k implement√°ci√≥ja. A feladat a k√∂vetkez≈ëkb≈ël
√°ll:
<ul>
<li>Elind√≠tani a dolgoz√≥k (b√°ny√°szok √©s √©p√≠t√©szek) sz√°lait
(<code>mineAction()</code> √©s <code>buildAction()</code>)</li>
<li>Elind√≠tani egy logol√≥ sz√°lat, ami bizonyos id≈ëk√∂z√∂nk√©nt ki√≠rja a
szimul√°ci√≥ haladt√°t (<code>loggingAction()</code>)</li>
<li>A <code>main</code>en bel√ºl megv√°rni, am√≠g a dolgoz√≥k sz√°lai
befejezik a munk√°t, majd ki√≠rni, hogy v√©ge a szimul√°ci√≥nak</li>
<li>Implement√°lni a <code>sleepForMsec(int msec)</code> met√≥dust, ami
az√©rt felel, hogy az azt megh√≠v√≥ sz√°lat ,,sleepeltesse‚Äô‚Äô a megszabott
ideig</li>
</ul></li>
</ul>
<p>Csak a <code>ThreadCraft.java</code> √°llom√°nyt t√∂ltsd fel.</p></li>
</ol>
<h1 class="hu" id="synchronized"><code
class="sourceCode java"><span class="kw">synchronized</span></code></h1>
<ol type="1">
<li><p>K√∂z√∂sen haszn√°lt adatok</p>
<p>Ind√≠ts el k√©t sz√°lat, melyek egy k√∂z√∂sen el√©rt list√°ba tesznek bele
√©rt√©keket az <code>1..1_000_000</code> intervallumb√≥l √∫gy, hogy az egyik
a p√°ratlan, a m√°sik p√°ros √©rt√©keit teszi be. A list√°ba az elemek
be√≠r√°s√°t m√©g ne szinkroniz√°ld.</p>
<ul>
<li>V√°rd meg a sz√°lak lefut√°s√°t az ismert m√≥dszerrel.</li>
<li>Vizsg√°ld meg milyen meglep≈ë jelens√©gek figyelhet≈ëk meg a list√°ban:
<ul>
<li>H√°ny eleme van a list√°nak? (egymilli√≥t v√°rn√°nk)
<ul>
<li>Tipp: a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/List.html#subList(int,int)"><code>subList</code></a>
m≈±velettel megvizsg√°lhat√≥ a list√°nak egy kis r√©sze.</li>
<li>Vagy: ki lehet √≠rni a list√°ban az inverzi√≥k (nagyobb √©rt√©k ut√°n
kisebb j√∂n) sz√°m√°t.</li>
</ul></li>
<li>Sorrendben vannak-e az elemek?</li>
<li>T√∂bb futtat√°s eset√©n kiv√©tel is fell√©phet.</li>
</ul></li>
<li>Haszn√°lj <code>synchronized</code> blokkot azon (√©s csak azon) a
ponton, ahol az elemeket a list√°hoz adod. A szinkroniz√°l√°s kulcsa legyen
maga a lista.
<ul>
<li>Hogyan v√°ltozik a lista tartalma? H√°ny eleme van?</li>
<li>Mi a helyzet a lista elemek sorrendj√©vel?</li>
</ul></li>
<li>‚ûø Opcion√°lis: m√≥dos√≠tsd a sz√°mok list√°ba helyez√©s√©t √∫gy, hogy,
mindig n√∂vekv≈ë sorrendben ker√ºljenek bele az elemek. Ehhez b≈ëv√≠tsd ki a
<code>synchronized</code> blokk hat√≥k√∂r√©t √∫gy, hogy legyen benne egy
el√°gaz√°s, ami garant√°lja, hogy mindig csak a r√°k√∂vetkez≈ë elem ker√ºlj√∂n
be a list√°ba. √úgyelj r√°, hogy ne maradjanak ki elemek.
<ul>
<li>Hogyan v√°ltozik a program fut√°si ideje ett≈ël a m√≥dos√≠t√°st√≥l?</li>
</ul></li>
</ul></li>
<li><p>üè† H√°zi feladat</p>
<p>√Åltal√°nos√≠tsd a ‚Äú<strong>K√∂z√∂sen haszn√°lt adatok</strong>‚Äù feladatot
a k√∂vetkez≈ëk√©pp.</p>
<ul>
<li>Kett≈ë helyett <code>n</code> sz√°l dolgozzon. Mindegyik az
intervallum <code>n</code>-edik √©rt√©k√©t tegye be a list√°ba.</li>
<li>Egy <code>isSynchronized</code> logikai √©rt√©k adja meg, hogy az
√©rt√©k beilleszt√©s√©nek m≈±velete szinkroniz√°lt legyen-e vagy sem.</li>
<li>Egy <code>isInOrder</code> egy logikai √©rt√©k adja meg, hogy az
√©rt√©kek sorrendben ker√ºljenek-e beilleszt√©sre.</li>
<li>‚ûø Opcion√°lis: oldd meg, hogy a k√≥d, amit a sz√°lak futtatnak, csak
egyszer legyen le√≠rva a forr√°sk√≥dba egy seg√©dmet√≥dusban, √©s a sz√°lak
k√©sz√≠t√©sekor ezt h√≠vd meg a megfelel≈ë param√©terez√©ssel.
<ul>
<li>Tipp: a seg√©dmet√≥dus visszat√©r√©si √©rt√©ke <code>Runnable</code>.</li>
</ul></li>
<li>A f≈ëprogram helyett legyen egy seg√©df√ºggv√©ny
(<code>useThreads</code>), ami a fenti logik√°t vez√©rli (l√©trehozza,
elind√≠tja, bev√°rja a sz√°lakat). Ennek a param√©terei legyenek az el≈ëbb
megadottak (<code>n</code>, <code>isSynchronized</code>,
<code>isInOrder</code>).</li>
<li>A f≈ëprogramban h√≠vd meg a <code>useThreads</code>-et t√∂bb k√ºl√∂nb√∂z≈ë
param√©terez√©s mellett √©s m√©rd ki a fut√°si id≈ëket a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/System.html#nanoTime()"><code>System.nanoTime()</code></a>
seg√≠ts√©g√©vel. A fut√°si id≈ëket a f≈ëprogram v√©g√©n √≠rd ki a sztenderd
kimenetre.</li>
</ul></li>
<li><p><code>ThreadSafeMutableInteger</code> oszt√°ly, a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/atomic/AtomicInteger.html"><code>java.util.concurrent.atomic.AtomicInteger</code></a>
egyszer≈± megfelel≈ëje</p>
<ol type="a">
<li><p>Implement√°ld a <code>ThreadSafeMutableInteger</code> oszt√°lyt,
mely a be√©p√≠tett <code>int</code> f√∂l√∂tti absztrakci√≥ √©s lehet≈ëv√© teszi,
hogy t√∂bb sz√°l is olvashassa/√≠rhassa az √°ltala t√°rolt sz√°mot sz√°lbiztos
m√≥don. Ehhez haszn√°ld a <code>synchronized</code> kulcssz√≥t vagy blokk
vagy met√≥dus szinten. Az oszt√°ly alapm≈±veletei a k√∂vetkez≈ëk
legyenek:</p>
<ul>
<li>k√©t konstruktor: <code>ThreadSafeMutableInteger()</code> √©s
<code>ThreadSafeMutableInteger(int)</code></li>
<li>√©rt√©k olvas√°sa: <code>int get()</code></li>
<li>√©rt√©k √≠r√°sa: <code>void set(int)</code></li>
</ul></li>
<li><p>Pr√≥b√°ld ki a megold√°st 10 sz√°llal √©s egy k√∂z√∂sen haszn√°lt
<code>ThreadSafeMutableInteger</code>rel, melyet minden sz√°l
<code>10_000_000</code>-szer n√∂veljen meg eggyel. A sz√°lak bev√°r√°sa ut√°n
√≠rd ki a v√©geredm√©nyt.</p></li>
<li><p>Atomicit√°st biztos√≠t√≥ m≈±veletek:</p>
<ul>
<li><code>int getAndIncrement()</code></li>
<li><code>int getAndDecrement()</code></li>
<li><code>int getAndAdd(int v)</code></li>
<li><code>int incrementAndGet()</code></li>
<li><code>int decrementAndGet()</code></li>
<li><code>addAndGet(int v)</code></li>
</ul></li>
<li><p>Pr√≥b√°ld ki a t√∂bbi m≈±veletet is. Ellen≈ërizd, hogy a v√©geredm√©ny
megfelel-e az elv√°rtnak.</p>
<ul>
<li>A sz√°lak fele n√∂velje, m√°sik fele cs√∂kkentse eggyel. Ehhez haszn√°ld
az <code>getAndIncrement</code> √©s <code>getAndDecrement</code>
m≈±veleteket.</li>
<li>A sz√°lak fele n√∂velje, m√°sik fele cs√∂kkentse kett≈ëvel az
<code>addAndGet</code> met√≥dus haszn√°lat√°val.</li>
</ul></li>
<li><p>Vizsg√°ld meg, mi t√∂rt√©nik, ha az <code>getAndIncrement</code> √©s
<code>getAndDecrement</code> helyett a <code>get</code> √©s
<code>set</code> m≈±veletek seg√≠ts√©g√©vel pr√≥b√°lod n√∂velni az √©rt√©ket. Mit
tapasztalsz? Mi√©rt lehet ez?</p></li>
<li><p>‚ûø Opcion√°lis: implement√°ld azokat a met√≥dusokat, melyek
tetsz≈ëleges akci√≥k atomikus v√©grehajt√°s√°t teszik lehet≈ëv√© az adaton,
majd teszteld a megold√°st:</p>
<ul>
<li><code>int getAndUpdate(IntUnaryOperator)</code></li>
<li><code>int updateAndGet(IntUnaryOperator)</code></li>
</ul></li>
</ol></li>
<li><p>üè† H√°zi feladat: <code>ThreadSafeMutableIntArray</code> oszt√°ly,
a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/atomic/AtomicIntegerArray.html"><code>java.util.concurrent.atomic.AtomicIntegerArray</code></a>
egyszer≈± megfelel≈ëje</p>
<ol type="a">
<li><p>K√©sz√≠tsd el a <code>ThreadSafeMutableIntArray</code>
adatszerkezetet, mely egy sz√°lbiztos <code>int</code> t√∂mb√∂t val√≥s√≠t
meg.</p>
<ul>
<li>A <code>ThreadSafeMutableIntArray</code> elemei l√©trehoz√°skor
<code>0</code>-ra inicializ√°l√≥dnak.</li>
<li>A reprezent√°ci√≥ban haszn√°lj sima <code>int[]</code>-√∂t.</li>
<li>‚ö†Ô∏è Fontos: elt√©r≈ë elemeket k√ºl√∂nb√∂z≈ë sz√°lakb√≥l blokkol√°s n√©lk√ºl
lehessen el√©rni.
<ul>
<li>Ez√©rt nem szabad az eg√©sz t√∂mb√∂t egyszerre z√°rolni a m≈±veletekben,
vagyis a <code>synchronized</code> met√≥dus <strong>nem j√≥</strong>.</li>
<li>Ehelyett hozz l√©tre egy <code>capacity</code> m√©ret≈±
<code>locks</code> t√∂mb√∂t <code>Object</code> t√≠pus√∫ elemekb≈ël. Ennek
seg√≠ts√©g√©vel a t√∂mbelemek egyedileg z√°rolhat√≥k.</li>
</ul></li>
</ul></li>
<li><p>Defini√°ld a k√∂vetkez≈ë m≈±veleteket az oszt√°lyban:</p>
<ul>
<li>Konstruktor: <code>ThreadSafeMutableIntArray(int capacity)</code>,
mely a <code>capacity</code> m√©ret≈± <code>int</code> t√∂mb√∂t, valamint az
egyes elemekhez tartoz√≥ z√°rakat tartalmaz√≥ <code>Object</code> t√∂mb√∂t
hozza l√©tre.
<ul>
<li>√úgyelj r√°, hogy m√≠g az <code>int[]</code> alapb√≥l megfelel≈ëen van
inicializ√°lva, addig az <code>Object[]</code> elemeit neked kell
inicializ√°lni. Elegend≈ë egyszer≈± <code>Object</code> p√©ld√°nyokat
beletenni.</li>
</ul></li>
<li>Az <code>idx</code> index≈± elem lek√©rdez√©se:
<code>int get(int idx)</code>. Ez a m≈±velet z√°rolja az
<code>idx</code>-edik elemhez tartoz√≥ kulcsot.</li>
<li>Az <code>idx</code> index≈± elem √≠r√°sa:
<code>void set(int idx, int newValue)</code>. Ez a m≈±velet z√°rolja az
<code>idx</code>-edik elemhez tartoz√≥ kulcsot.</li>
</ul></li>
<li><p>Pr√≥b√°ld ki a megval√≥s√≠t√°st a f≈ëprogramban. Ehhez hozz l√©tre 10
sz√°lat √©s egy k√∂z√∂sen haszn√°lt, k√©telem≈±
<code>ThreadSafeMutableIntArray</code>-t. A sz√°lak fele a
<code>0</code>-√°s index≈± elemet, m√°sik fele az <code>1</code>-es index≈±
elemet √≠rja.</p>
<ul>
<li>Minden sz√°l n√∂velje egyes√©vel az √°ltala haszn√°lt elemet eg√©szen
<code>10_000_000</code>-ig.</li>
<li>√çrd ki az eredm√©nyeket a sztenderd kimenetre.</li>
<li>Tapasztalsz-e valamilyen furcsas√°got? Hogyan lehetne ezt
megsz√ºntetni?</li>
</ul></li>
<li><p>‚ûø Opcion√°lis: atomicit√°st biztos√≠t√≥ m≈±veletek:</p>
<ul>
<li><code>int updateAndGet(int n, IntUnaryOperator)</code></li>
<li><code>int getAndUpdate(int n, IntUnaryOperator)</code></li>
</ul></li>
</ol></li>
</ol>
<h1 class="hu" id="executorservice"><code
class="sourceCode java"><span class="bu">ExecutorService</span></code></h1>
<ol type="1">
<li><p>√Åbr√°zoljunk egy olyan rendszert, amelyben n√©h√°ny √ºgyf√©l
k√∂lcs√∂n√∂ket vesz fel egy bankt√≥l.</p>
<p>Az <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/Executors.html#newFixedThreadPool(int)">Executors.newFixedThreadPool</a>
seg√≠ts√©g√©vel l√©trehozott poolba ker√ºljenek be a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)">submit()</a>
m≈±velet seg√≠ts√©g√©vel az √ºgyfeleket √°br√°zol√≥ sz√°lak.</p>
<p>A sz√°lak megadott sz√°m√∫ (pl. 10000) fordul√≥n kereszt√ºl vesznek fel
k√∂lcs√∂n√∂ket. A <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ThreadLocalRandom.html#nextInt(int,int)">ThreadLocalRandom.current().nextInt(min,
max)</a> sorsolja ki a k√∂lcs√∂n nagys√°g√°t minden fordul√≥ban, pl. 100 √©s
1000 √©rt√©k k√∂z√∂tt. A banknak van egy k√∂zponti sz√°ml√°l√≥ja, ahol az eddig
felvett k√∂lcs√∂n√∂k √∂sszeg√©t t√°rolja, ennek el√©r√©se legyen megfelel≈ëen
szinkroniz√°lt. Tov√°bb√° az √ºgyfelek is t√°rolj√°k k√ºl√∂n-k√ºl√∂n, mennyi
k√∂lcs√∂nt vettek fel; ezt az √©rt√©ket a fut√°suk v√©g√©n √≠rj√°k be egy t√∂mb
megfelel≈ë poz√≠ci√≥j√°ra.</p>
<p>A pool v√°rja be a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ExecutorService.html#shutdown()">shutdown()</a>
√©s az <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ExecutorService.html#awaitTermination(long,java.util.concurrent.TimeUnit)">awaitTermination()</a>
m≈±veletek seg√≠ts√©g√©vel, hogy mindegyik √ºgyf√©lsz√°l befejezze a fut√°s√°t,
majd a program v√©g√©n ellen≈ërizz√ºk, hogy a k√∂z√∂sen nyilv√°ntartott
sz√°ml√°l√≥ √©rt√©ke megegyezik-e az √ºgyfelenk√©nt nyilv√°ntartott k√∂lcs√∂n√∂k
√∂sszeg√©vel.</p></li>
<li><p>Ugyanaz a feladat, mint az el≈ëz≈ë r√©szben, azonban most <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.util.concurrent.Callable)">ezt
a submit() m≈±veletet</a> haszn√°ljuk.</p>
<p>Az √ºgyf√©l k√∂lcs√∂neinek √∂sszege most ne t√∂mbbe √≠r√≥djon a sz√°l
fut√°s√°nak a v√©g√©n, hanem a <code>submit()</code>-nak √°tadott n√©vtelen
met√≥dus a visszat√©r√©si √©rt√©ke legyen. A <code>submit()</code>
visszat√©r√©si √©rt√©ke egy <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/Future.html">Future</a>,
amelyb≈ël a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/Future.html#get()">get()</a>
m≈±velettel lehet kik√©rni a kisz√°m√≠tott √©rt√©ket.</p>
<p>A program csak a k√©tf√©le m√≥don √∂sszes√≠tett k√∂lcs√∂n√∂k egyez√©s√©nek
megvizsg√°l√°sa ut√°n h√≠vja meg a <code>shutdown()</code> m≈±veletet a
poolra.</p></li>
<li><p>üè† H√°zi feladat: a <code>Switcheroo</code> oszt√°ly f≈ëprogramja
ind√≠tson el 10 sz√°lat. Legyen a rendszerben egy k√∂z√∂sen el√©rt, 100 elem≈±
t√∂mb, amelynek minden eleme kezdetben az 1000 √©rt√©ket tartalmazza. A
sz√°lak 10000 l√©p√©sen kereszt√ºl a k√∂vetkez≈ët teszik: v√©letlenszer≈±en
kiv√°lasztj√°k a t√∂mb k√©t poz√≠ci√≥j√°t, √©s v√©letlenszer≈± √©rt√©ket √°ttesznek
egyikb≈ël a m√°sikba (legfeljebb annyit, amennyi az els≈ë indexen el√©rhet≈ë
volt). Az √°tt√©tel m≈±velete legyen megfelel≈ëen szinkroniz√°lva.</p>
<p>A program lefut√°sa v√©g√©n ellen≈ërzend≈ë, hogy a t√∂mb √∂sszege
megmaradt.</p></li>
<li><p>üè† H√°zi feladat: az <code>InefficientSorter</code> oszt√°ly
f≈ëprogramja ind√≠tson el 10 sz√°lat. Legyen a rendszerben egy k√∂z√∂sen
el√©rt, 100 elem≈± t√∂mb, amelynek minden eleme kezdetben v√©letlenszer≈±
√©rt√©keket tartalmazzon. A sz√°lak 10000 l√©p√©sen kereszt√ºl a k√∂vetkez≈ët
teszik: v√©letlenszer≈±en kiv√°lasztj√°k a t√∂mb k√©t poz√≠ci√≥j√°t, √©s ha a
kisebb indexen a m√°sikn√°l nagyobb √©rt√©k tal√°lhat√≥, akkor megcser√©lik a
kett≈ët. A csere m≈±velete legyen megfelel≈ëen szinkroniz√°lva.</p>
<p>A legt√∂bb lefut√°s v√©g√©n a t√∂mbnek rendezett√© kell v√°lnia.
Ellen≈ërzend≈ë, hogy ez megt√∂rt√©nt-e, √©s az is, hogy a t√∂mb elemei mind
rendben megmaradtak-e.</p></li>
</ol>
<h1 class="hu" id="szinkroniz√°lt-adatszerkezetek">Szinkroniz√°lt
adatszerkezetek</h1>
<ol type="1">
<li><p>Szinkroniz√°lt list√°k</p>
<ol type="a">
<li><p>K√©sz√≠tsd el a <code>nonSyncIterate</code> met√≥dust, amely egy <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Collection.html"><code
class="sourceCode java">java<span class="op">.</span><span class="fu">util</span><span class="op">.</span><span class="fu">Collection</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span></code></a>
adatszerkezetet j√°r be elemenk√©nt egy <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Iterator.html"><code
class="sourceCode java"><span class="bu">Iterator</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span></code></a>
bej√°r√≥ seg√≠ts√©g√©vel, √©s ki√≠rja az √©rintett elemeket. A met√≥dus kapjon
meg tov√°bb√° egy sz√°mot is, ami szerepeljen a ki√≠r√°sban. A
<code>syncIterate</code> met√≥dus h√≠vjon √°t az el≈ëbbi met√≥dusra √∫gy, hogy
k√∂r√ºlveszi a h√≠v√°st egy <code>synchronized</code> blokkal, amelynek a
kulcsa legyen a param√©terk√©nt megkapott adatszerkezet.</p>
<p>K√©sz√≠ts az al√°bbi m√≥dokon list√°t sok (pl. <code>100_000</code>)
elemb≈ël.</p>
<ul>
<li>Egyszer≈± <code>ArrayList</code>.</li>
<li>Egyszer≈± <code>LinkedList</code>.</li>
<li>Egyszer≈± <code>Vector</code>.</li>
<li>Valamelyik fentib≈ël <a
href=""><code>Collections.synchronizedCollection</code></a> seg√≠ts√©g√©vel
k√©sz√≠tett, szinkroniz√°lt adatszerkezet.</li>
<li>Valamelyik fentib≈ël <a
href=""><code>Collections.synchronizedList</code></a> seg√≠ts√©g√©vel
k√©sz√≠tett, szinkroniz√°lt adatszerkezet.</li>
</ul>
<p>A met√≥dusok √©s az adatszerkezetek min√©l t√∂bb kombin√°ci√≥j√°val pr√≥b√°ld
ki az al√°bbiakat, √©s figyeld meg a kimenet szerkezet√©t.</p>
<p>Ind√≠ts k√©t sz√°lat. Mindk√©t sz√°l h√≠vja meg a kiv√°lasztott met√≥dust,
√°tadva a kiv√°lasztott lista hivatkoz√°s√°t √©s a saj√°t sorsz√°m√°t.</p></li>
<li><p>üè† H√°zi feladat: van egy k√∂z√∂sen el√©rt list√°nk
(<code>original</code>), amely kezdetben az <code>1, 2, ...</code>
√©rt√©kekkel van felt√∂ltve. Az utols√≥ √©rt√©k
<code>THREAD_COUNT * ELEMS_PER_THREAD</code>, ahol
<code>THREAD_COUNT</code> tetsz≈ëleges √©rt√©k (legal√°bb 2),
<code>ELEMS_PER_THREAD</code> pedig viszonylag nagy (pl.
<code>100_000</code>). Legyen egy m√°sik k√∂z√∂sen el√©rt list√°nk is
(<code>result</code>), ez kezdetben √ºres.</p>
<ul>
<li>Egy <code>ExecutorService</code> hajtson v√©gre
<code>THREAD_COUNT</code> feladatot, amelyek
<code>ELEMS_PER_THREAD</code> l√©p√©sen kereszt√ºl leveszik
<code>original</code> els≈ë elem√©t (<a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/List.html#remove(int)"><code>remove</code></a>),
√©s beteszik <code>result</code> elej√©re (<a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/List.html#add(int,E)"><code>add</code></a>).</li>
<li>√Åll√≠tsd le az <code>ExecutorService</code>t, majd √≠rasd ki
<code>result</code> els≈ë 100 elem√©t.
<ul>
<li>A legt√∂bb lefut√°s sor√°n <code>ConcurrentModificationException</code>
l√©p fel.</li>
<li>Pr√≥b√°ld ki: ha mindk√©t lista szinkroniz√°lt, akkor nem l√©p fel a
kiv√©tel.</li>
</ul></li>
</ul></li>
</ol></li>
<li><p><code>ConcurrentMap</code></p>
<ol type="a">
<li><p>Van egy napt√°runk, amelybe tal√°lkoz√≥k id≈ëpontj√°t jegyezz√ºk be.
Egy-egy tal√°lkoz√≥ 10 perces, √©s egym√°ssal nem √ºtk√∂zhetnek. A napt√°rba 10
sz√°l betesz 5000-5000 db tal√°lkoz√≥t, mik√∂zben m√°sik 10 sz√°l 2500-2500 db
tal√°lkoz√≥t t√∂r√∂l bel≈ële folyamatosan. Egy k√ºl√∂n sz√°l
sz√°zadm√°sodpercenk√©nt megkeresi √©s ki√≠rja a k√∂vetkez≈ë esed√©kes tal√°lkoz√≥
id≈ëpontj√°t. Ennek a feladatnak a megold√°sa a
<code>MeetingCalendar.java</code> f√°jlban √©rhet≈ë el.</p>
<p>Mivel a program sima <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashMap.html"><code>java.util.HashMap</code></a>-et
haszn√°l a tal√°lkoz√≥k t√°rol√°s√°ra, ami nem sz√°lbiztos, √°ltal√°ban nem fut
v√©gig, hanem valamelyik sz√°l <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/ConcurrentModificationException.html"><code>ConcurrentModificationException</code></a>
kiv√©telt v√°lt ki.</p>
<p>Jav√≠tsd ki a programot. Ehhez haszn√°ld a m√°r tanult <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Collections.html#synchronizedMap(java.util.Map)"><code>java.util.Collections.synchronizedMap()</code></a>
met√≥dust, az iter√°ci√≥t pedig k√ºl√∂n szinkroniz√°ld.</p></li>
<li><p>M√≥dos√≠tsd az el≈ëz≈ë feladat megold√°s√°t √∫gy, hogy a
<code>java.util.Collections.synchronizedMap()</code> met√≥dus haszn√°lata
helyett az eg√©sz adatszerkezetet cser√©ld ki <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html"><code>java.util.concurrent.ConcurrentHashMap</code></a>-re.
T√∂r√∂ld az iter√°ci√≥ k√∂r√ºl lev≈ë szinkroniz√°ci√≥t is, mert enn√©l az
adatszerkezetn√©l erre nincs sz√ºks√©g. Figyeld meg (a ki√≠r√≥ sz√°l
ki√≠r√°sainak sz√°ma alapj√°n), hogy melyik megold√°s a gyorsabb.</p></li>
<li><p>K√©sz√≠ts olyan programot, ami egy szinkroniz√°lt fajta
<code>Map</code>-et haszn√°l: betev≈ë, kivev≈ë, bej√°r√≥ m≈±veleteket h√≠v meg
r√° sok sz√°lb√≥l. A program legyen min√©l egyszer≈±bb, az el≈ëz≈ë feladatban
lev≈ë bonyolults√°g√°t nem kell megk√∂zel√≠tenie.</p>
<p>A programmal demonstr√°ld, hogy egyfajta param√©terez√©s (pl. a sz√°lak
sz√°m√°nak vagy a <code>Map</code>-be ker√ºl≈ë elemek sz√°m√°nak m√≥dos√≠t√°sa)
eset√©n a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Collections.html#synchronizedMap(java.util.Map)"><code>synchronizedMap()</code></a>,
m√°sfajta param√©terez√©s eset√©n a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html"><code>ConcurrentHashMap</code></a>
tud gyorsabb lenni.</p></li>
<li><p>üè† H√°zi feladat: szimul√°ld egy t≈ëzsde (egyszer≈±s√≠tett) m≈±k√∂d√©s√©t.
A r√©szv√©nyek (3 nagybet≈±) √°r√°t (lebeg≈ëpontos) egy map adatszerkezet
t√°rolja. Minden r√©szv√©ny 100 $-r√≥l indul. 100 br√≥ker 10000 k√∂r√∂n √°t vesz
vagy ad el r√©szv√©nyt. Ha egy r√©szv√©ny vesznek, akkor az 1%-kal dr√°gul,
ha pedig eladj√°k, akkor ugyanennyivel cs√∂kkent az √°ra. Van egy tov√°bbi
sz√°l is, amely m√°sodpercenk√©nt egyszer ki√≠rja az aktu√°lis √°rfolyamokat.
Haszn√°ld a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Collections.html#synchronizedMap(java.util.Map)"><code>Collections.synchronizedMap()</code></a>
h√≠v√°st az adatszerkezet sz√°lbiztoss√° t√©tel√©hez.</p></li>
<li><p>üè† H√°zi feladat: alak√≠tsd √°t az el≈ëz≈ë megold√°sodat √∫gy, hogy <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Collections.html#synchronizedMap(java.util.Map)"><code>ConcurrentHashMap</code></a>
adatszerkezetet haszn√°lsz. Mivel az egyes r√©szv√©ny√°rfolyamok egym√°st√≥l
f√ºggetlenek, ne lass√≠tsd a programot az iter√°ci√≥ felesleges
szinkroniz√°ci√≥j√°val.</p></li>
</ol></li>
<li><p><code>BlockingQueue</code></p>
<p>Az al√°bbi feladatokhoz el√©rhet≈ë v√°z <code>PipelineN.java</code> n√©ven
(<code>N</code>=1,2,3).</p>
<p>K√©sz√≠ts adatcsatorn√°t (pipeline) a k√∂vetkez≈ëk√©ppen.</p>
<ol type="a">
<li>Az adatcsatorna √°lljon k√©t <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/BlockingQueue.html"><code>BlockingQueue</code></a>b√≥l,
az els≈ë sz√∂vegeket, a m√°sodik sz√°mokat sz√°ll√≠t.
<ul>
<li>P√©ld√°nyos√≠t√°shoz <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ArrayBlockingQueue.html"><code>ArrayBlockingQueue</code></a>
vagy <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/LinkedBlockingQueue.html"><code>LinkedBlockingQueue</code></a>
haszn√°lhat√≥.</li>
<li>Egy sz√°l felt√∂lti az els≈ët n√©h√°ny el≈ëre megadott sz√∂veggel.
<ul>
<li>Vari√°ns: a sz√∂vegek j√∂hetnek egy f√°jlb√≥l is.</li>
</ul></li>
<li>Egy m√°sik sz√°l kiolvassa az elemeket az els≈ë sorb√≥l, √©s a hosszukat
beteszi a m√°sodikba.</li>
<li>Egy harmadik sz√°l kiolvassa az elemeket a m√°sodikb√≥l, √©s ki√≠rja ≈ëket
a sztenderd kimenetre.</li>
<li>Azt, hogy a sorb√≥l nem olvashat√≥ tov√°bbi elem, jelezd extrem√°lis
elemmel (<code>""</code>, <code>Integer.MAX_VALUE</code>).
<ul>
<li>Ezeknek c√©lszer≈± szimbolikus nevet is adni, pl.
<code>NO_FURTHER_INPUT1</code> √©s <code>NO_FURTHER_INPUT2</code>.</li>
</ul></li>
<li>Ha az adatcsatorna sz√°lait thread pool kezeli, ne felejtsd el
le√°ll√≠tani.</li>
<li>B√≥nusz feladat: k√≠s√©rletezz az adatcsatorna param√©tereivel.
<ul>
<li>A csatorna m√©rete legyen (sokkal) kisebb, mint ah√°ny sort a f√°jl
tartalmaz.</li>
<li>A betev≈ë √©s kivev≈ë m≈±veletek k√∂z√ºl haszn√°lj k√ºl√∂nb√∂z≈ë
jelleg≈±eket.</li>
<li>Szimul√°ld az elemek el≈ë√°ll√≠t√°s√°nak/feldolgoz√°s√°nak idej√©t
v√°rakoz√°ssal.</li>
</ul></li>
</ul></li>
<li>K√©sz√≠ts sok komponensb≈ël √°ll√≥ adatcsatorn√°t.
<ul>
<li>Adott sok met√≥dus, ilyen form√°ban (de m√°s-m√°s k√©plettel):
<code>Function&lt;Integer, Integer&gt; fun = n -&gt; 2 * n + 1;</code>
<ul>
<li>Ehhez import√°lni kell: <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/function/Function.html"><code>java.util.function.Function</code></a></li>
<li>Haszn√°lni √≠gy lehet: <code>fun.apply(123)</code></li>
</ul></li>
<li>K√©sz√≠ts olyan adatcsatorn√°t, ami sok sz√°lat √©s <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/BlockingQueue.html"><code>BlockingQueue</code></a>t
haszn√°l.
<ul>
<li>Az els≈ë sz√°l el≈ëvesz n√©h√°ny sz√°mot, √©s beteszi az els≈ë <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/BlockingQueue.html"><code>BlockingQueue</code></a>ba.</li>
<li>A k√∂vetkez≈ë sz√°lak kiveszik az elemeket a megfelel≈ë <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/BlockingQueue.html"><code>BlockingQueue</code></a>b√≥l,
√©s a megfelel≈ë f√ºggv√©ny seg√≠ts√©g√©vel √°talak√≠tva beteszik a
k√∂vetkez≈ëbe.</li>
<li>A v√©gs≈ë sz√°l a ki√©rkez≈ë elemeket ki√≠rja a sztenderd kimenetre.</li>
</ul></li>
</ul></li>
<li>K√©sz√≠ts adatcsatorn√°t pr√≠mek sz≈±r√©s√©re.
<ul>
<li>A csatorna √°lljon <code>stageCount</code> darabsz√°m√∫ komponensb≈ël.
P√°ronk√©nt legyenek √∂sszek√∂tve egy-egy <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/BlockingQueue.html"><code>BlockingQueue</code></a>val,
√©s legyen m√©g egy tov√°bbi <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/BlockingQueue.html"><code>BlockingQueue</code></a>
is.</li>
<li>Az els≈ë <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/BlockingQueue.html"><code>BlockingQueue</code></a>
kapja meg a 3, 5, 7, ‚Ä¶ bemenetet valamilyen fels≈ë korl√°tig, √©s v√©g√ºl az
<code>Integer.MAX_VALUE</code> √©rt√©ket, ami a bemenet v√©g√©t jelzi.</li>
<li>Egy thread poolba ker√ºlj√∂n bele <code>stageCount</code> darab
<code>Callable</code>, amelyek a k√∂vetkez≈ëket tegy√©k.
<ul>
<li>Mindegyik <code>Callable</code> ismer k√©t szomsz√©dos
<code>BlockingQueue</code>t.</li>
<li>El≈ësz√∂r is felveszi a legels≈ë be√©rkez≈ë sz√°mot. Ez lesz a
<code>Callable</code>h√∂z tartoz√≥ pr√≠msz√°m.</li>
<li>Ezut√°n sorban felveszi a t√∂bbi sz√°mot is.
<ul>
<li>Ha <code>Integer.MAX_VALUE</code>t tal√°l, azt tov√°bbk√ºldi, majd
befejezi a fut√°s√°t.</li>
<li>Egy√©bk√©nt: ha a sz√°m oszthat√≥ a pr√≠mmel, kisz≈±ri (elteszi egy
list√°ba), ha nem oszthat√≥, akkor tov√°bbk√ºldi a m√°sik <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/BlockingQueue.html"><code>BlockingQueue</code></a>ba.</li>
</ul></li>
<li>A fut√°sa v√©g√©n visszat√©r a kisz≈±rt sz√°mok list√°j√°val.</li>
</ul></li>
<li>A thread pool az <code>invokeAll</code> h√≠v√°s seg√≠ts√©g√©vel elind√≠tja
a csatorna √∂sszes komponens√©t √©s kiveszi bel≈ël√ºk a kisz≈±rt sz√°mok
list√°it, amelyeket √≠rj ki.</li>
<li>Az utols√≥ csatorn√°b√≥l szint√©n √≠rd ki a (majdnem garant√°ltan)
pr√≠msz√°mok list√°j√°t.</li>
<li>A kimenet az al√°bbihoz hasonl√≥ kin√©zet≈± legyen.</li>
</ul>
<pre><code>[9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99]
[25, 35, 55, 65, 85, 95]
[49, 77, 91]
[]
[]
[]
[]
Remaining: [23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]</code></pre>
<ul>
<li>Ha a <code>Callable</code>√∂k elt√°rolj√°k egy (rajtuk k√≠v√ºl
elhelyezett) t√∂mbben a pr√≠msz√°maik √©rt√©k√©t, akkor √≠gy is kin√©zhet a
ki√≠r√°s.</li>
</ul>
<pre><code>Filtered by 3: [9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99]
Filtered by 5: [25, 35, 55, 65, 85, 95]
Filtered by 7: [49, 77, 91]
Filtered by 11: []
Filtered by 13: []
Filtered by 17: []
Filtered by 19: []
Remaining: [23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]</code></pre></li>
</ol></li>
</ol>
<h1 class="hu" id="holtpont">Holtpont</h1>
<ol type="1">
<li><p>√âtkez≈ë filoz√≥fusok</p>
<p>√ñt csendes filoz√≥fus √ºl egy kerek asztaln√°l, az asztal k√∂zep√©n egy
t√°l spagetti. √ñt villa is van az asztalon, minden k√©t filoz√≥fus k√∂z√∂tt
egy. Minden filoz√≥fus felv√°ltva gondolkodik √©s eszik. Egy filoz√≥fus csak
akkor tud enni, ha mindk√©t kez√©ben villa van. Minden vill√°t egyszerre
csak egy filoz√≥fus haszn√°lhat, teh√°tt csak akkor tud vele enni, ha m√°s
nem haszn√°lja. Miut√°n a filoz√≥fus befejezte az ev√©st, visszateszi a
vill√°kat, hogy a szomsz√©dai is tudj√°k ≈ëket haszn√°lni. A filoz√≥fus csak
akkor tudja felvenni a bal vagy a jobb vill√°j√°t, ha azok az asztalon
vannak, √©s csak azokkal tudja megkezdeni az ev√©st.</p>
<p>Ezt a jelenetet szimul√°lja a <code>Philosophers</code> oszt√°ly.
Sajnos, a szimul√°ci√≥ id≈ënk√©nt holtpontba ker√ºl, ha az √∂sszes filoz√≥fus
egyszerre veszi fel a bal vill√°j√°t, √©s v√°r a jobbra.</p>
<p>Jav√≠tsd ki a szimul√°ci√≥t √∫gy, hogy minden filoz√≥fus el≈ëbb az
alacsonyabb sorsz√°m√∫ vill√°t vegye el, √©s ut√°na a magasabb sorsz√°m√∫t, √≠gy
elker√ºlve a holtpontot.</p></li>
<li><p>Egy termel≈ë sz√°l egy sorba elemeket helyez, amelyeket onnan egy
fogyaszt√≥ sz√°l kivesz, √©s ki√≠r a k√©perny≈ëre. Id≈ënk√©nt egy harmadik sz√°l
pillanatk√©pet √≠r ki a sor √°llapot√°r√≥l.</p>
<p>Sajnos a <code>ProducerConsumer</code> oszt√°ly hib√°san m≈±k√∂dik, mert
a sor el√©r√©se sor√°n versenyhelyzetek √°llnak fenn.</p>
<p>Jav√≠tsd meg a programot √∫gy, hogy sz√°lbiztoss√° teszed a sor el√©r√©s√©t.
A k√©perny≈ëre √≠r√°st is tedd konzisztenss√©.</p></li>
</ol>
<h1 class="hu" id="wait-notify"><code
class="sourceCode java">wait</code>-<code
class="sourceCode java">notify</code></h1>
<ol type="1">
<li><p>Az alv√≥ borb√©ly probl√©ma</p>
<ol type="a">
<li><p>Egy borb√©lynak van egy sz√©ke a munkaterm√©ben √©s van egy v√°r√≥terme
adott sz√°m√∫ sz√©kkel. Amint lev√°gja egy √ºgyfel√©nek a haj√°t, √°tmegy a
v√°r√≥terembe, √©s megn√©zi, hogy vannak-e ott m√°sok. Ha van, akkor beengedi
egyik√ºket a munkaterembe, √©s lev√°gja a haj√°t. Ha nincsenek, akkor
visszamegy a munkaterm√©be, √©s alszik a sz√©k√©ben. Amint √©rkezik egy √∫j
√ºgyf√©l, megn√©zi, hogy mit csin√°l a borb√©ly. Ha alszik, akkor
fel√©breszti, √©s be√ºl a munkaterembe. Ha hajat v√°g, akkor a v√°r√≥teremben
marad. Ha ott van szabad sz√©k, akkor kiv√°rja a sor√°t, ha nincs, akkor
elmegy.</p>
<p>A szimul√°ci√≥ r√©szleges megval√≥s√≠t√°sa a <code>BarberShop.java</code>
√°llom√°nyban tal√°lhat√≥. A feladat a hi√°nyz√≥ r√©szek kit√∂lt√©se, amelyek a
borb√©ly alv√≥ √©s az √ºgyfelek √©breszt≈ë tev√©kenys√©gei. Val√≥s√≠tsd meg ezeket
a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#wait()"><code>wait()</code></a>
√©s a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#notify()"><code>notify()</code></a>
met√≥dusok seg√≠ts√©g√©vel.</p></li>
<li><p>Tov√°bbfejleszt√©s</p>
<p>A <code>Barber</code> sz√°l megszak√≠t√°sa nem igaz√°n eleg√°ns. Ehelyett
haszn√°ljuk ink√°bb a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#wait(long)"><code>wait(long timeoutMillis)</code></a>
met√≥dust, amivel korl√°tozni tudjuk a borb√©ly alv√°s√°nak hossz√°t.</p></li>
</ol></li>
<li><p>üè† H√°zi feladat: saj√°t blokkol√≥ sor</p>
<ol type="a">
<li>Val√≥s√≠tsd meg a saj√°t blokkol√≥ sorodat a v√°rakoz√°s √©s √©breszt√©s
technika seg√≠ts√©g√©vel! Haszn√°ld az egyik kor√°bbi feladatunk megold√°s√°t a
tesztel√©s√©hez! El√©g, ha a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/BlockingQueue.html#take()"><code>take()</code></a>
m≈±veletet meg√≠rod. Mivel a sor nem tartja nyilv√°n, hogy ki v√°rakozik r√°,
hagyn√°ld a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#notifyAll()"><code>notifyAll()</code></a>
met√≥dust, amely minden v√°rakoz√≥ sz√°lat fel√©breszt! Terjeszd ki a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Queue.html"><code>Queue</code></a>
interf√©szt √©s valamelyik megval√≥s√≠t√°s√°t, pl. az <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/ArrayDeque.html"><code>ArrayDeque</code></a>-t.</li>
</ol></li>
</ol>
<h1 class="hu" id="explicit-z√°rak">Explicit z√°rak</h1>
<ol type="1">
<li><p>√çr√≥k √©s olvas√≥k</p>
<p>Egy adatb√°zist p√°rhuzamosan √≠rnak √©s olvasnak k√ºl√∂nb√∂z≈ë sz√°lak. Az
egyszer≈±s√©g kedv√©√©rt most felt√©telezz√ºk, hogy az adatb√°zist csak egyben
lehet z√°rolni.</p>
<p>A szimul√°ci√≥ megval√≥s√≠t√°sa a <code>ReadersWriters.java</code>
√°llom√°nyban tal√°lhat√≥. Vedd k√∂r√ºl az olvas√°st √©s az √≠r√°st
szinkroniz√°ci√≥s blokkokkal.</p></li>
<li><p>Olvas√°si √©s √≠r√°si z√°rak</p>
<p>A szinkroniz√°ci√≥s blokkok haszn√°lata jelent≈ësen lerontja a
teljes√≠tm√©nyt. Ugyanakkor a konkurens √≠r√°sok soha nem jelentenek
probl√©m√°t. Kiz√°r√≥lag a konkurens √≠r√°sokat kell megakad√°lyoznunk, √©s az
√≠r√°sokkal konkurens olvas√°sokat. Cser√©ld ki a szinkroniz√°ci√≥s programok
haszn√°lat√°t olvas√°si √©s √≠r√°si z√°rakra a <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/locks/ReadWriteLock.html">ReadWriteLock</a>
objektumok haszn√°lat√°val.</p></li>
<li><p>Igazs√°gos sorrend</p>
<p>Ha t√∫l sok az olvas√≥, akkor ki√©heztethetik az √≠r√≥kat. Ezt
megakad√°lyozhatjuk igazs√°gos sorrend biztos√≠t√°s√°val az olvas√°si √©s √≠r√°si
z√°rakban: <a
href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/locks/ReentrantReadWriteLock.html#%3Cinit%3E(boolean)">ReentrantReadWriteLock(boolean
fair)</a>. Hasonl√≠tsd √∂ssze az eredm√©nyeket az el≈ëz≈ëekkel.</p></li>
</ol>
<h1 class="hu" id="gyakorl√≥-feladat">Gyakorl√≥ feladat</h1>
<ol type="1">
<li><p>Aukci√≥</p>
<p>Egy aukci√≥s h√°z reprezent√°ci√≥j√°t fogjuk elk√©sz√≠teni. Az aukci√≥s h√°z
modern m≈±v√©szeket foglalkoztat, akik <a
href="https://en.wikipedia.org/wiki/Non-fungible_token">Non-fungible
token</a>, r√∂viden NFT technol√≥gia seg√≠ts√©g√©vel √©rt√©kes√≠tik a m≈±veiket.
Mi ezeket az NFT-ket fogjuk kezelni, maguk a m≈±t√°rgyak nem jelennek meg
a programban.</p>
<p>A sz√∂vegben a nagybet≈±vel szedett √©rt√©kek konstansok, a kiindul√≥
<code>AuctionHouse.java</code> f√°jlban tal√°lhat√≥k meg. Ugyanebben a
f√°jlban van a <code>runChecks()</code> met√≥dus, amire a f≈ëprogram az
utols√≥ l√©p√©s√©ben √°th√≠v, ez a tesztel≈ë k√≥d ‚Äì nem garant√°lja a program
m≈±k√∂d√©s√©nek helyess√©g√©t, de ha azt √≠rja, hogy valami rossz, akkor minden
bizonnyal m√©g nem helyes a program.</p>
<p>A f√°jl v√©g√©n tal√°lhat√≥ <code>sleepForMsec</code> seg√©df√ºggv√©nyt lehet
haszn√°lni v√°rakoz√°shoz, a <code>getRandomBetween</code> seg√©df√ºggv√©nyt
pedig v√©letlensz√°mok gener√°l√°s√°ra.</p>
<ol type="a">
<li><p>M≈±v√©sz</p>
<p>Ebben a feladatban is √©s minden tov√°bbi r√©szben is √∫gy kell meg√≠rni a
k√≥dot, hogy ne fordulhasson benne el≈ë se versenyhelyzet, se
holtpont.</p>
<p>A megold√°s r√©szletei TODO alakban olvashat√≥k a let√∂lthet≈ë, kiindul√≥
<code>AuctionHouse.java</code> f√°jlban.</p>
<p>A f≈ëprogram elind√≠tja a m≈±v√©szeket (√©s majd a tov√°bbi feladatokban a
t√∂bbi szerepl≈ët is) egy-egy sz√°lk√©nt √©s bev√°rja, hogy mindenki
elk√©sz√ºlj√∂n. A helyesen m≈±k√∂d≈ë programban minden szerepl≈ë √∂nmag√°t√≥l le
kell, hogy √°lljon p√°r m√°sodpercen bel√ºl.</p>
<p>A programban <code>ARTIST_COUNT</code> m≈±v√©szt foglalkoztatunk, akik
20 ezredm√°sodpercenk√©nt l√©trehoznak egy-egy m≈±alkot√°st v√©letlenszer≈±en
100..1000 k√∂z√∂tti √°ron, √©s beteszik az <code>nfts</code> t√∂mb soron
k√∂vetkez≈ë elem√©be. Ha m√°r t√∂bb m≈±alkot√°s nem f√©r be a <code>nfts</code>
t√∂mbbe, vagy ha a <code>remainingNftPrice</code> √©rt√©kn√©l ezzel m√°r t√∂bb
lenne a m≈±alkot√°sok √∂ssz√©rt√©ke, akkor a m≈±v√©sz befejezi az
alkot√°st.</p></li>
<li><p>üè† H√°zi feladat: √Årver√©svezet≈ë</p>
<p>Az √°rver√©svezet≈ë addig dolgozik, am√≠g a m≈±v√©szek k√∂z√ºl m√©g van akt√≠v,
illetve azut√°n, hogy minden m≈±v√©sz elk√©sz√ºlt, m√©g 100 √°rver√©st folytat
le.</p>
<ul>
<li>M√°sik sz√°l m≈±k√∂d√©s√©t az <a
href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Thread.html#isAlive()"><code>isAlive()</code>
m≈±velet</a> megh√≠v√°s√°val lehet lek√©rdezni.</li>
</ul>
<p>Mindegyik √°rver√©s √∫gy kezd≈ëdik, hogy az √°rver√©svezet≈ë kiv√°laszt egy
el√©rhet≈ë NFT-t, √©s az <code>auctionQueue</code> v√°ltoz√≥n kereszt√ºl
el√©rhet≈ëv√© tesz egy <code>BlockingQueue</code>-t, amibe
<code>AuctionOffer</code> elemeket k√ºldenek majd be a 3. r√©szfeladat
m≈±gy≈±jt≈ëi.</p>
<ul>
<li>Ebben a feladatban m√©g senki sem fog licit√°lni, de nem baj,
felk√©sz√ºl√ºnk erre az eshet≈ës√©gre.</li>
<li>Az √°rver√©svezet≈ë legfeljebb <code>MAX_AUCTION_OFFERS</code>
alkalommal v√°r licitet az <code>auctionQueue</code>n kereszt√ºl, minden
alkalommal legfeljebb egy ezredm√°sodpercig v√°r arra, hogy megjelenjen
egy √∫j licit. Ha a licit jobb √°rat aj√°nl, mint a kor√°bbiak, akkor azt
tekinti a nyer≈ënek.
<ul>
<li>Vigy√°zat, a fut√°s elej√©n el≈ëfordulhat, hogy m√©g nem k√©sz√ºlt el egy
NFT sem, akkor persze m√©g nem lehet √°rver√©st ind√≠tani.</li>
</ul></li>
<li>Ha nem j√∂n √∫j licit az id≈ëkorl√°ton bel√ºl, vagy
<code>MAX_AUCTION_OFFERS</code> licitk√∂r m√°r lezajlott, akkor az
√°rver√©svezet≈ë lez√°rja a licitet.
<ul>
<li>Elt√°rolja a licit gy≈ëztes√©nek a nev√©t. M√°st nem kell sz√°mon tartani
r√≥luk, csak azt, hogy kik gy≈ëztek (legal√°bb egyszer) √°rver√©sen.</li>
<li>A <code>soldItemCount</code> √©rt√©ke n≈ëj√∂n eggyel.</li>
<li>Az aukci√≥s h√°z jutal√©ka (<code>totalCommission</code>) n≈ëj√∂n meg a
teljes v√©tel√°r (az NFT alap√°ra plusz a legjobb aj√°nlat) 10%-√°val.</li>
</ul></li>
<li>K√©t √°rver√©s k√∂z√∂tt legyen 3 ezredm√°sodperc ‚Äúsz√ºnet‚Äù, ez alatt az
<code>auctionQueue</code> legyen <code>null</code>.</li>
</ul></li>
<li><p>üè† H√°zi feladat: M≈±gy≈±jt≈ë</p>
<p>Legyen <code>COLLECTOR_COUNT</code> darab m≈±gy≈±jt≈ë
<code>Collector1</code>, <code>Collector2</code> stb. n√©ven, akik addig
licit√°lnak a k√∂vetkez≈ëk szerint, am√≠g az √°rver√©svezet≈ë dolgozik (m≈±k√∂dik
a sz√°la).</p>
<p>A m≈±gy≈±jt≈ë minden licit√°l√°si k√≠s√©rlet el≈ëtt v√©letlenszer≈±en v√°r
<code>COLLECTOR_MIN_SLEEP</code>..<code>COLLECTOR_MAX_SLEEP</code>
m√°sodpercig.</p>
<p>Ezut√°n megn√©zi, hogy van-e el√©rhet≈ë √°rver√©s (az
<code>auctionQueue</code> tartalmaz-e √©rv√©nyes objektumot), ha nem,
megn√∂veli a <code>noAuctionAvailableCount</code> v√°ltoz√≥ √©rt√©k√©t, √©s
√∫jra v√°r.</p>
<p>Ha el√©rhet≈ë aukci√≥, tesz egy
<code>1</code>..<code>MAX_COLLECTOR_OFFER</code> k√∂z√∂tti √©rt√©k≈±
aj√°nlatot, kiv√©ve, ha ez egy olyan aukci√≥, amin m√°r r√©szt vett.</p></li>
</ol></li>
</ol>
<h1 class="hu" id="beadand√≥-feladatok">Beadand√≥ feladatok</h1>
<ol type="1">
<li><p>K√©s≈ëbb lesz el√©rhet≈ë.</p></li>
<li><p>K√©s≈ëbb lesz el√©rhet≈ë.</p></li>
</ol>
</body>
</html>
